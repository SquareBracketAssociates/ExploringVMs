[[[eval=true
Gofer it
	smalltalkhubUser: 'ClementBera' project: '3DaysVM';
	version: 'ConfigurationOf3DaysVM-ClementBera.1';
load.
(Smalltalk at: #ConfigurationOf3DaysVM) loadBleedingEdge.
Smalltalk snapshot: true andQuit: false.
]]]

! Context and Stack Machines

!!!! Introduction
This lecture is part of a larger set of lecture whose goal is to teach VM internals by building a simple VM. The current lecture presents function activations, function returns and the implementation of closures. 

To succeed, the student has to implement several interpreters with an increasing level of complexity. An interpreter is a program that executes other programs written in a programming language. All the interpreters are designed to execute code written in a very simple programming language, SmiLang.

Although it is recommended to implement all the interpreters described in this lecture, the student has only to understand and implement the context interpreters described in Sections 2 and 5 and read the Sections 1 and 7 to continue with the virtual machine lecture. The Ssections 3, 4, and 6 deals with interpreters using a native stack and are not required to understand the next parts of the lecture.

%todo put real links to sections

!!!! Concepts
Students will learn the following concepts during this tutorial:

- 	Context interpreter
-	Stack Interpreter
-	Stack page management
-	Closure creation and activation
--	Remote temporary variable access
--	Non- local returns


!!!! Outline

This tutorial is divided in several sections:
#	Description of the SmiLang language
#	Implementation of a simple context interpreter
#	Implementation of a simple stack interpreter
#	Addition of stack page management in to the stack interpreter
#	Introduction of naive closures in to the context interpreter
#	Introduction of real closures in to the stack interpreter
#	Discussion: what are the difference between the Smalltalk model and the SmiLang model


!!!! Thanks
Thanks to Cyril Ferlicot, Vincent Blondeau for the early reviews and runs of the tutorial.


! SmiLang: A Simple Integer Language

During this tutorial, the student will implement several interpreters of the language SmiLang. “Smi” is the nickname for SmallIntegers in several VM development teams, hence SmiLang is a language that just manipulates Smis. This section describes briefly SmiLang, which is a very simple language. SmiLang has only function activations, function returns, temporary variables, and primitive operations on Smis.

!! SmiLang Basics
SmiLang only manipulates Smis: all the variables values are Smis and are initialized by default to 0.  Functions can only be called using with static calls. Every function has to return a value (no procedures). 


The Smi language has 7 instructions:

[[[eval=true
  SmiCompiler usedInstructions do: [ :each |
	stream 
		<< '# ""'
		<< (each name allButFirst: 3)
		<< '"": '
		<< each comment
		<< String cr ].
]]]

!! SmiLang Examples

[[[eval=true

| exampleSelectors selectorTexts |

exampleSelectors := #(#one #add:to: #example7TempAndCallAndCallArgs).
selectorTexts := {
	#one -> 'zero argument function which returns the constant Smi 1' .
	#add:to: -> '2 arguments function which adds the values of the 2 arguments and returns it' .
	#example7TempAndCallAndCallArgs -> 'zero argument function with two static function calls. It also uses a temporary variable'
	} asDictionary.
	
stream << 'Here are '.
exampleSelectors size printOn: stream.
stream << ' examples that show the whole language:'.

exampleSelectors do: [ :each |
	stream cr.
	stream 
		<< '!!!! Function '
		<< each.
	stream cr.
	stream 
		<< 'Function =='
		<< each
		<< '== is a '
		<< (selectorTexts at: each)
		<< '.'.
	stream cr.
	stream cr.
	stream << 'Source code:'.
	stream cr.
	stream << (SmiExamples>>#one) sourceCode asPillarSourceCode.
	stream cr.
	stream << 'Instructions:'.
	stream cr.
	stream << (SmiCompiler new compilePharoMethod: (SmiExamples>>#one)) printString asPillarSourceCode. ].
]]]

!!! We are set

The complete SmiLang has been introduced. This language may not be usable for a real application but it is perfect for our exercise which consists of the different implementations of function calls and returns.

! Context Interpreter

A context interpreter is an interpreter which represents the activation of each function by an object or a data structure called context. The call stack is composed of a linked list of contexts.

!! What is a Context ?

A Context is an object or a data structure (depending on the implementing language) which represents a function activation. In this section, contexts are instances of the class ==SmiContext==.

A Context holds information such as:
- The values of local variables
- The program counter (also called instruction pointer)
- The function being executed (because the function holds the instruction to be executed)
- The context that activated it (also called caller or sender)

Figure *@context1* shows a given computation state showing the relationships between context, stack, function and instructions in SmiLang.

+Relationships between Context, Stack, Function and Instructions in a context interpreter.>file://figures/context1.pdf|width=75|label=context1+

Let us explain this Figure class by class.

!!!! Context.
- The sender field of the Context references another context, the one which activated it. Such context chain is created during function call: the sender context is a function activation with a call to the context function.
- The program counter field holds 3, which means the next instruction the Interpreter will execute is the third instruction of the function.
- The function field is a reference to the function being activated. A context refers to the function because the function is a holder of instructions to be executed. 
- The stack pointer field holds 6, which means that in the space allocated for this specific context stack, which is in our case 7, only 6 values are currently used and the value at position 6 is the top of the stack.
- Lastly, the context references the stack. The context’s stack values are specific to the function activation and independent from other contexts. The values are unrelated to other function activations.

!!!! Function.
- ==Function name== is useful for debugging purpose.
- ==numArguments== and ==numTemporaries== describe the information mandatory to the execution of the function. They are determined by the compiler.= The interpreter and debugger use these values to figure out, for each value on stack, if they correspond to an argument, a temp or a spilled value.
- ==maxStackSize== . For performance reason, the Context, on creation, allocate for its stack enough space for the maximum size its stack can have. The maximum size that the stack can have is specified in the function by the compiler (see field name max stack size which holds 7 in  Figure *@context1*). 

!!!! Stack.

The stack is associated to a context for a function activation. This stack has not a regular stack API such as ==push:== or ==pop==. It has API such as ==at:== or ==at:put:== that the context uses based on the current stackPointer to do stack operations. For example, ==(stack at: stackPointer)== is the equivalent of ==stack top==.

The stack is composed in order as follow:
- The values of the function arguments.
- The values of the temporary variables.
- The spilled values, which are the values pushed on stack by previously executed instructions.

!! Concrete Example: Activation of function add:to:

Remember ==add:to:== function definition is: 

[[[eval=true
stream << (SmiExamples>>#add:to:) sourceCode asPillarSourceCode.
]]]

This function is invoked in particular by the function ==example07TempAndCallAndCallArgs==. 
[[[eval=true
stream << (SmiExamples>>#example07TempAndCallAndCallArgs) sourceCode asPillarSourceCode.
]]]

In Figure *@context2*, the Context represents the activation of the function ==add:to:== within the function ==example07TempAndCallAndCallArgs==.

The sender field holds the activation of the function ==example07TempAndCallAndCallArgs==. As we can see, the function has a call to function ==add:to:==.

+Context and collaborators for the ==add:to:== call in ==example07TempAndCallAndCallArgs==.>file://figures/context2.pdf|width=78|label=context2+

The programCounter is 2, which means that 
- the  first instructions ==1| pushTemp 2== has already been done or is currently being done.
- The second instruction, ==2| pushTemp 1== is the next instruction to be executed. Note that in most interpreter implementations, the ==pushTemp== instruction works both for arguments and temporary variables depending on the value of the temp index encoded in the instruction. For store, it consumes the value on the stack. For fetch, it pushes the value on the stack. In this case the instruction is used to access the arguments values.

The function field holds a reference to the function ==add:to:==. This function has 2 arguments, 0 temporary variables and a stack that can go up to 4 slots. It has a list of 4 instructions.

The current stack holds the values of the 2 arguments and the spilled value 2 due to the first instruction ==1| pushTemp 2== that has been executed.


!! Interpretation

""Example 1:"" Interpretation of ==1 + 2==

The figure *@contextInterpretation1* shows the state of a context's stack at each pc during the execution of 1 + 2.

+Stack state at each pc during the interpretation of ==1 \+ 2==.>file://figures/contextInterpretation1.pdf|width=70|label=contextInterpretation1+ 

- ""Step 1"": When the interpretation of 1 + 2 starts, stack pointer is at 0, 2 slots are already allocated on stack for the computation, pc is 1.

- ""Step 2"": First instruction execution (pushSmi 1): the constant 1 is pushed on stack. StackPointer is now 1.

- ""Step 3"": Second instruction execution (pushSmi 2):  the constant 2 is pushed on stack. Stack Pointer is now 2.

- ""Step 4"": Third instruction execution (primitive +):  the two constants are popped from the stack, the interpreter computes the result (by asking the host language or the cpu) , and pushes the result on stack. The stack pointer is now 1. The value at the second stack position is 2 but it should not be reached by execution any more.

""Example 2:"" Interpretation of ==temp1 := 1. temp2 := temp1 + 3.==

+Stack state for the first pcs during the interpretation of ==temp1 := 1. temp2 := temp1 \+ 3==.>file://figures/contextInterpretation2.pdf|width=75|label=contextInterpretation2+

The first steps of the interpretation are drawn in figure *@contextInterpretation2*. Try to draw or imagine the next steps.

!! Calls and Returns

In the two first examples we described the instructions that applied inside a function activation. Now let’s discuss the two interesting instructions, function calls and returns. They require the creation or the termination of a function activation.

!!! Function calls

The call instruction creates a new context, pops the arguments from the top of the stack and copy them to the new context’s stack. It then proceeds execution in the freshly created context. Indeed, remember that prior to the call execution, the argument values are in top of the stack of the current context. Once the call is actually performed, the arguments are the first elements of the stack followed by the temporaries of the new function.

!!! Returns

The returnTop instruction pushes the top of stack of the active context on the top of stack of the sender context. It then terminates the active context and resumes execution in the sender context.

!! Build a Context Interpreter

In this exercise, you will build a context Interpreter.

Open a Pharo 4 image, load the package SmiLang you can find on *http://smalltalkhub.com/mc/ClementBera/3DaysVM/main*.

Go to the package tag ==SmiLang>>Context== interpreter. A class SmiContext is given and is a possible implementation of a Context for SmiLang.  A ==SmiContextInterpreter== class skeleton is given, but many methods are not implemented (they only hold ==self shouldBeImplemented==). 

The interpretation starts with a fake Context which holds flags. The Interpreter then calls a function (the public API, ==interpret:==, specified in the public method protocol, precise the function to call). The interpreter keeps interpreting instructions until it returns to the flagged context, which signals the end of the execution. It then returns the value computed.

The SmiContextInterpreterTests have to pass.
We suggest to look at the code and the compiled version of the examples.

Good luck and have fun.

! Simple Stack Interpreter

In this section the student will build a stack interpreter. Instead of considering contexts as separated objects, this interpreter uses a contiguous memory space where function activations reuse arguments pushed on the stack instead of copying them over the new function activation.

The interpreter is considered as simple as it conceptually holds a single monolithic ""infinite stack"". In subsequent implementation we will deal with limited memory stack using stack pages. 
But let us start by discussing the limits of our first naïve context interpreter.

There are different issues to the Context Interpreter performance-wise:

- Time is wasted when copying the arguments at each function call from the caller context to the freshly created context. If one would design a context interpreter which does not copy the arguments (hence they would stay in the caller context), then a context needs additional far memory reads to access its arguments, which is in practice even slower.
- A second problem is that Contexts are separate data structures and hence can be allocated by the host language, like C, far from each other. This implies that memory reads are spread in the memory and this is problematic for performance (mismatch with cpu caches). 
- Another issue is that hardware-implemented cpu instructions like calls and returns are difficult or even impossible to use directly with contexts when in the future the developer will add a just-in-time compiler.

!! Call Stack

In one sentence, a stack interpreter is a context interpreter where all the contexts have been merged into a single stack called "call stack" or "native stack".

+Representation of a native stack.>file://figures/stack1.pdf|width=75|label=stack1+

The figure *@stack1* describes the representation of a native stack.

The native stack holds information relative to each context next to each other. Assuming that the stack grows down, the data up to a stack frame is related to the sender of the function activation and the data down is related the function called by the activation. 

The interpreter, instead of knowing the active context, knows directly the state of the active function activation: 
- the active function
- the pc (program counter) being executed
- the active frame pointer: it points to the beginning of the function activation in the native stack
- the stack pointer, it points to the top of the native stack and the top of active stack frame (they are the same). Values will be pushed and popped there.

In the native stack, we call ""stack frame"" a portion of the stack that represents a function activation (it corresponds to a context in the previous interpreter, except that the stack frame size is variable depending on how many values were pushed on stack before the activation of the next stack frame). Except the active stack frame, a stack frame is represented in order as follow:
- Temporaries: Allocated at stack frame creation, this space hold the values of the temporary variables of the activation. The size of this space is known thanks to the ==numTemps== property of the function.
- Spilled Values: These values are pushed on top of the stack for the execution by different instructions. The size of this zone is variable, depending on the current execution state. It has a size of 0 at stack frame activation time. Then, for example, if a ==pushSmi== instruction is performed, it will have a size of 1, as the Smi will be pushed on stack.
- Arguments:When calling a function, the interpreter pushes the arguments of the function called on the stack. On the contrary to the context interpreter, the arguments are never copied. Arguments are accessed in the caller stack frame relatively to the active stack frame frame pointer (this is detailed later in the lecture).
- ==Function==, ==pc== and ==frame pointer==: Once a new function is activated, the interpreter can’t hold anymore the pc, the function and the frame pointer of the previous activation. It needs to hold the information related to the new stack frame created for the function being called. To remember the information, the interpreter pushes on stack the active function, pc and frame pointer. On return, it will set its values with the values on stack. The framePointer holds a reference to the beginning of the previous stack frame. 

The active stack frame, i.e. the bottom stack frame, is different. The active function, pc and framepointer are directly held by the interpreter (they are not on stack). In practice, this avoids memory reads and writes if the interpreter variables (currentFunction, pc, framePointer) are in registers instead of in memory.

!!! Concrete example: Activation of the function add:to:

The figure *@stack2* describes the same example than for the context interpreter in Section 2. Don’t hesitate to compare both architectures if you don’t understand everything.

[[[eval=true
stream << (SmiExamples>>#add:to:) sourceCode asPillarSourceCode.
]]]

+Representation of a native stack.>file://figures/stack2.pdf|width=75|label=stack2+

The interpreter holds:
- A reference to the function being executed, the function ==add:to:==
- The pc of the next instruction to execute, 2
- The frame pointer corresponding to the beginning of the current stack frame for the activation of the method ==add:to:==
- The stack pointer, which is the last value being used on stack and the top of the active stack frame

The active stack frame starts with a framePointer which refers to the framePointer of the previous stack frame, i.e., the beginning of the previous stack frame. For example, in figure *@stack2* the interpreter frame pointer points to slot 9 which refers to the previous stack frame start.

!! Temporary access

We assume that the compiler forbids writing into the function arguments (compilation error). Hence, the store into temporary variable instruction remains simple as it assumes the temp index is the index of a temporary variable. Remember that the temporaries are now stored at the beginning of the stack frame (just after the frame pointer).

The ==pushTemp== instruction is different. Depending on the tempIndex and the value of numArgs in the function, two cases are found:

- ""The tempIndex corresponds to an argument."" Its value is accessed in the caller frame relatively to the active frame pointer. The previous frame has at its end the argument values, its function and its pc. The interpreter needs to substract 3 from the stack pointer to reach the zone in the previous stack frame holding arguments, then substract the number of argument and add the tempIndex to access the correct field.

+Representation of a native stack.>file://figures/tempAccess1.pdf|width=75|label=tempAccess1+

- ""The tempIndex corresponds to a temporary variable."" Hence we can access the value relatively to the framepointer. We need to add the tempIndex to the framePointer and substract the number of arguments as they are stored on the caller frame.

+Representation of a native stack.>file://figures/tempAccess2.pdf|width=75|label=tempAccess2+

!! Call Instruction

The call instruction is different from the context interpreter as one needs to update the interpreter state and create a new stack frame instead of simply creating a new context.

The call instruction works as follow:
- Pushes the pc, the active function and the frame pointer on stack.
- Sets up the stack zone after the new frame pointer with only slots for temporary variables (no slots for arguments as they are accessed from the caller frame). It usually implies to update the stackPointer and set the temporary variable fields to a default value (0 in our case).

!! Return instructions

The return instruction needs to:
- Pop the stack until the previous frame state. This means popping the stack up to the previous frame pointer, then popping and restoring the previous active function, frame pointer and pc, and lastly popping the arguments of the function call.
- Push the returned result on stack

!! Build a stack interpreter

In this exercise you will build a Stack Interpreter.

Open a Pharo 4 image, load the package ==SmiLang== you can find on *http://smalltalkhub.com/mc/ClementBera/3DaysVM/main*.

Go to the package tag ==SmiLang>>Stack interpreter==. A ==SmiStackInterpreter== class skeleton is given, but many methods are not implemented (they only hold ==self shouldBeImplemented==). 

The interpretation starts with a fake stack frame which holds flags. The Interpreter then calls a function (the public API, ==#interpret:==, specified in the public method protocol, defines the function to call). The interpreter keeps interpreting instructions until it returns to the flagged stack frame, which signals the end of the execution. It then returns the computed value.

The ==SmiStackInterpreterTests== have to pass to proceed the lecture. 

Good luck and have fun !

! Stack pages

!!! Problem

The Stack interpreter previously built is nice but it has a critical flaw. It considers the stack to be infinite. This is not possible as you need to specify to the computer a size to allocate for the stack. This size can’t be too big because if the program uses multiple processes, each process requires a separate stack. 

!!! Solution

A common solution is to split the stack into stack pages of limited size. When the bottom of a stack page is reached, the interpreter switch to a new stack page. The stack pages are created at interpreter start-up and there are of  limited number. Once all the pages are full, different strategies exist depending on the language you want to implement:
- Raise a StackOverflow error
- Serialize a few stack page to free them, and once a serialized stack page needs to be used again materialize it.

!!! Implementation

The implementation is as follow:
- On function activation, in addition to what is done in the ==StackInterpreter==, the interpreter estimates the stack frame size based on the max stack size field of the function. If there is not enough room in the stack page for the next stack frame, the interpreter switches to a new stack page.
- On return, in addition to the ==StackInterpreter== behavior, if at the top of a stack page, the interpreter returns to a stack frame in another stack page. The top of a stack page can be marked (for example, the saved pc can be saved as a negative value) so the interpreter knows it has to do a return across stack pages.

!!! Exercise

As an exercise, have the ==SmiStackInterpreterWithStackPagesTests== pass by implementing the ==SmiStackInterpreterWithStackPages==.

!!! Comment

A good ==StackInterpreter== needs to be implemented in a way that returns and calls across stack pages are uncommon because they are slower than regular calls and returns. For example, if the interpreter notices that many calls are done across stack pages, it would copy the bottom stack frame of the previous page to the beginning of a new page.

! Naive closures in the Context Interpreter

!! Introduction

In this section the student will introduce closures the context interpreter.

A closure is an object that references a function and an environment, as represented on figure *@closure*. In this implementation, the function will be anonymous and the environment is the context in which the closure was created. We call the environment refered by a closure the closure’s outer context.

+Closure representation.>file://figures/closure.pdf|width=75|label=closure+

In addition to regular function, closure’s function activation (contexts representing closure activations) can access the closure, as represented on figure *@closureContext*. 

+Context versus Closure Context.>file://figures/closureContext.pdf|width=70|label=closureContext+

If the closure is defined in another closure, then the closure’s outer context is a closure context, which has itself a closure with an outer context. We call the ""outer context chain"" the list of outer context from the closure’s direct outer context to the first context which is not a closure activation. Such an outer context chain is represented on figure *@OuterContextChain*.The last context of the chain is called the closure’s ""home context"". If the closure is not nested in another closure, then the closure outer context is its home context.

+Outer context chain.>file://figures/OuterContextChain.pdf|width=100|label=OuterContextChain+

In this implementation, the interpreter uses the closure’s outer context for two different purposes:
- Remote temporary access
- Non local return

!!! Remote temporary access

The first feature, present in most language having closures, is the access of remote temporary variables. The closure’s function can access temporary variables that are held not in the current context, but in the closure’s outer context. In addition, if the closure outer context is already a closure activation, the closure activation can access the temporary variables of the closure’s outer context’s closure’s outer context. In case of a closure nested many times, the function can access all the temporary variables of all the enclosing contexts.

!!! Non local return

The second feature, present at least in Ruby in the form of Procedure returns and in Smalltalk, is called non local return. When a closure’s activation performs a non local return, it returns from the closure’s home context instead of the closure’s context sender. To learn more about non local return, you can read the section ""14.4 Returning from inside a Block"" from the book ""Deep into Pharo"".

!! New instructions














