[[[eval=true
Gofer it
	smalltalkhubUser: 'ClementBera' project: '3DaysVM';
	version: 'ConfigurationOf3DaysVM-ClementBera.1';
load.
(Smalltalk at: #ConfigurationOf3DaysVM) loadBleedingEdge.
Smalltalk snapshot: true andQuit: false.
]]]

! Context and Stack Machines

!!!! Introduction
This lecture is part of a larger set of lecture whose goal is to teach VM internals by building a simple VM. The current lecture presents function activations, function returns and the implementation of closures. 

To succeed, the student has to implement several interpreters with an increasing level of complexity. An interpreter is a program that executes other programs written in a programming language. All the interpreters are designed to execute code written in a very simple programming language, SmiLang.

Although it is recommended to implement all the interpreters described in this lecture, the student has only to understand and implement the context interpreters described in Sections 2 and 5 and read the Sections 1 and 7 to continue with the virtual machine lecture. The Ssections 3, 4, and 6 deals with interpreters using a native stack and are not required to understand the next parts of the lecture.

%todo put real links to sections

!!!! Concepts
Students will learn the following concepts during this tutorial:

- 	Context interpreter
-	Stack Interpreter
-	Stack page management
-	Closure creation and activation
--	Remote temporary variable access
--	Non- local returns


!!!! Outline

This tutorial is divided in several sections:
#	Description of the SmiLang language
#	Implementation of a simple context interpreter
#	Implementation of a simple stack interpreter
#	Addition of stack page management in to the stack interpreter
#	Introduction of naive closures in to the context interpreter
#	Introduction of real closures in to the stack interpreter
#	Discussion: what are the difference between the Smalltalk model and the SmiLang model


!!!! Thanks
Thanks to Cyril Ferlicot, Vincent Blondeau for the early reviews and runs of the tutorial.


! SmiLang: A Simple Integer Language

During this tutorial, the student will implement several interpreters of the language SmiLang. “Smi” is the nickname for SmallIntegers in several VM development teams, hence SmiLang is a language that just manipulates Smis. This section describes briefly SmiLang, which is a very simple language. SmiLang has only function activations, function returns, temporary variables, and primitive operations on Smis.

!! SmiLang Basics
SmiLang only manipulates Smis: all the variables values are Smis and are initialized by default to 0.  Functions can only be called using with static calls. Every function has to return a value (no procedures). 


The Smi language has 7 instructions:

[[[eval=true
  SmiCompiler usedInstructions do: [ :each |
	stream 
		<< '# ""'
		<< (each name allButFirst: 3)
		<< '"": '
		<< each comment
		<< String cr ].
]]]

!! SmiLang Examples

[[[eval=true

| exampleSelectors selectorTexts |

exampleSelectors := #(#one #add:to: #example7TempAndCallAndCallArgs).
selectorTexts := {
	#one -> 'zero argument function which returns the constant Smi 1' .
	#add:to: -> '2 arguments function which adds the values of the 2 arguments and returns it' .
	#example7TempAndCallAndCallArgs -> 'zero argument function with two static function calls. It also uses a temporary variable'
	} asDictionary.
	
stream << 'Here are '.
exampleSelectors size printOn: stream.
stream << ' examples that show the whole language:'.

exampleSelectors do: [ :each |
	stream cr.
	stream 
		<< '!!!! Function '
		<< each.
	stream cr.
	stream 
		<< 'Function =='
		<< each
		<< '== is a '
		<< (selectorTexts at: each)
		<< '.'.
	stream cr.
	stream cr.
	stream << 'Source code:'.
	stream cr.
	stream << (SmiExamples>>#one) sourceCode asPillarSourceCode.
	stream cr.
	stream << 'Instructions:'.
	stream cr.
	stream << (SmiCompiler new compilePharoMethod: (SmiExamples>>#one)) printString asPillarSourceCode. ].
]]]

!!! We are set

The complete SmiLang has been introduced. This language may not be usable for a real application but it is perfect for our exercise which consists of the different implementations of function calls and returns.

! Context Interpreter

A context interpreter is an interpreter which represents the activation of each function by an object or a data structure called context. The call stack is composed of a linked list of contexts.

!! What is a Context ?

A Context is an object or a data structure (depending on the implementing language) which represents a function activation. In this section, contexts are instances of the class ==SmiContext==.

A Context holds information such as:
- The values of local variables
- The program counter (also called instruction pointer)
- The function being executed (because the function holds the instruction to be executed)
- The context that activated it (also called caller or sender)

Figure *@context1* shows a given computation state showing the relationships between context, stack, function and instructions in SmiLang.

+Relationships between Context, Stack, Function and Instructions in a context interpreter.>file://figures/context1.pdf|width=75|label=context1+

Let us explain this Figure class by class.

!!!! Context.
- The sender field of the Context references another context, the one which activated it. Such context chain is created during function call: the sender context is a function activation with a call to the context function.
- The program counter field holds 3, which means the next instruction the Interpreter will execute is the third instruction of the function.
- The function field is a reference to the function being activated. A context refers to the function because the function is a holder of instructions to be executed. 
- The stack pointer field holds 6, which means that in the space allocated for this specific context stack, which is in our case 7, only 6 values are currently used and the value at position 6 is the top of the stack.
- Lastly, the context references the stack. The context’s stack values are specific to the function activation and independent from other contexts. The values are unrelated to other function activations.

!!!! Function.
- ==Function name== is useful for debugging purpose.
- ==numArguments== and ==numTemporaries== describe the information mandatory to the execution of the function. They are determined by the compiler.= The interpreter and debugger use these values to figure out, for each value on stack, if they correspond to an argument, a temp or a spilled value.
- ==maxStackSize== . For performance reason, the Context, on creation, allocate for its stack enough space for the maximum size its stack can have. The maximum size that the stack can have is specified in the function by the compiler (see field name max stack size which holds 7 in  Figure *@context1*). 

!!!! Stack.

The stack is associated to a context for a function activation. This stack has not a regular stack API such as ==push:== or ==pop==. It has API such as ==at:== or ==at:put:== that the context uses based on the current stackPointer to do stack operations. For example, ==(stack at: stackPointer)== is the equivalent of ==stack top==.

The stack is composed in order as follow:
- The values of the function arguments.
- The values of the temporary variables.
- The spilled values, which are the values pushed on stack by previously executed instructions.

!! Concrete Example: Activation of function add:to:

Remember ==add:to:== function definition is: 

[[[eval=true
stream << (SmiExamples>>#add:to:) sourceCode asPillarSourceCode.
]]]

This function is invoked in particular by the function ==example07TempAndCallAndCallArgs==. 
[[[eval=true
stream << (SmiExamples>>#example07TempAndCallAndCallArgs) sourceCode asPillarSourceCode.
]]]

In Figure *@context2*, the Context represents the activation of the function ==add:to:== within the function ==example07TempAndCallAndCallArgs==.

The sender field holds the activation of the function ==example07TempAndCallAndCallArgs==. As we can see, the function has a call to function ==add:to:==.

+Context and collaborators for the ==add:to:== call in ==example07TempAndCallAndCallArgs==.>file://figures/context2.pdf|width=75|label=context2+

The programCounter is 2, which means that 
- the  first instructions ==1| pushTemp 2== has already been done or is currently being done.
- The second instruction, ==2| pushTemp 1== is the next instruction to be executed. Note that in most interpreter implementations, the ==pushTemp== instruction works both for arguments and temporary variables depending on the value of the temp index encoded in the instruction. For store, it consumes the value on the stack. For fetch, it pushes the value on the stack. In this case the instruction is used to access the arguments values.

The function field holds a reference to the function ==add:to:==. This function has 2 arguments, 0 temporary variables and a stack that can go up to 4 slots. It has a list of 4 instructions.

The current stack holds the values of the 2 arguments and the spilled value 2 due to the first instruction ==1| pushTemp 2== that has been executed.


!! Interpretation

""Example 1:"" Interpretation of ==1 + 2==

The figure *@contextInterpretation1* shows the state of a context's stack at each pc during the execution of 1 + 2.

- ""Step 1"": When the interpretation of 1 + 2 starts, stack pointer is at 0, 2 slots are already allocated on stack for the computation, pc is 1.

- ""Step 2"": First instruction execution (pushSmi 1): the constant 1 is pushed on stack. StackPointer is now 1.

- ""Step 3"": Second instruction execution (pushSmi 2):  the constant 2 is pushed on stack. Stack Pointer is now 2.

- ""Step 4"": Third instruction execution (primitive +):  the two constants are popped from the stack, the interpreter computes the result (by asking the host language or the cpu) , and pushes the result on stack. The stack pointer is now 1. The value at the second stack position is 2 but it should not be reached by execution any more.

+Stack state at each pc during the interpretation of ==1 \+ 2==.>file://figures/contextInterpretation1.pdf|width=75|label=contextInterpretation1+

""Example 2:"" Interpretation of ==temp1 :\= 1. temp2 :\= temp1 + 3.==

+Stack state for the first pcs during the interpretation of ==temp1 := 1. temp2 := temp1 \+ 3==.>file://figures/contextInterpretation1.pdf|width=75|label=contextInterpretation1+

The first steps of the interpretation are drawn. Try to draw or imagine the next steps
